// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: account.proto

#ifndef PROTOBUF_account_2eproto__INCLUDED
#define PROTOBUF_account_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace zhibo_account {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_account_2eproto();
void protobuf_AssignDesc_account_2eproto();
void protobuf_ShutdownFile_account_2eproto();

class OuterProfile;
class TokenBox;
class PassToken;
class ServiceToken;
class OpenAccountInfo;
class AccountInfo;
class OpenAccountInfoStore;
class PassTokenStore;
class PwdInfo;
class WxOldUserInfo;

// ===================================================================

class OuterProfile : public ::google::protobuf::Message {
 public:
  OuterProfile();
  virtual ~OuterProfile();

  OuterProfile(const OuterProfile& from);

  inline OuterProfile& operator=(const OuterProfile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OuterProfile& default_instance();

  void Swap(OuterProfile* other);

  // implements Message ----------------------------------------------

  OuterProfile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OuterProfile& from);
  void MergeFrom(const OuterProfile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nickname = 1;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 1;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string headimgurl = 2;
  inline bool has_headimgurl() const;
  inline void clear_headimgurl();
  static const int kHeadimgurlFieldNumber = 2;
  inline const ::std::string& headimgurl() const;
  inline void set_headimgurl(const ::std::string& value);
  inline void set_headimgurl(const char* value);
  inline void set_headimgurl(const char* value, size_t size);
  inline ::std::string* mutable_headimgurl();
  inline ::std::string* release_headimgurl();
  inline void set_allocated_headimgurl(::std::string* headimgurl);

  // optional uint32 sex = 3;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 3;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // optional uint32 certification_type = 4;
  inline bool has_certification_type() const;
  inline void clear_certification_type();
  static const int kCertificationTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 certification_type() const;
  inline void set_certification_type(::google::protobuf::uint32 value);

  // optional string certification = 5;
  inline bool has_certification() const;
  inline void clear_certification();
  static const int kCertificationFieldNumber = 5;
  inline const ::std::string& certification() const;
  inline void set_certification(const ::std::string& value);
  inline void set_certification(const char* value);
  inline void set_certification(const char* value, size_t size);
  inline ::std::string* mutable_certification();
  inline ::std::string* release_certification();
  inline void set_allocated_certification(::std::string* certification);

  // optional string uid = 6;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 6;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // @@protoc_insertion_point(class_scope:zhibo_account.OuterProfile)
 private:
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_headimgurl();
  inline void clear_has_headimgurl();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_certification_type();
  inline void clear_has_certification_type();
  inline void set_has_certification();
  inline void clear_has_certification();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* nickname_;
  ::std::string* headimgurl_;
  ::google::protobuf::uint32 sex_;
  ::google::protobuf::uint32 certification_type_;
  ::std::string* certification_;
  ::std::string* uid_;
  friend void  protobuf_AddDesc_account_2eproto();
  friend void protobuf_AssignDesc_account_2eproto();
  friend void protobuf_ShutdownFile_account_2eproto();

  void InitAsDefaultInstance();
  static OuterProfile* default_instance_;
};
// -------------------------------------------------------------------

class TokenBox : public ::google::protobuf::Message {
 public:
  TokenBox();
  virtual ~TokenBox();

  TokenBox(const TokenBox& from);

  inline TokenBox& operator=(const TokenBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TokenBox& default_instance();

  void Swap(TokenBox* other);

  // implements Message ----------------------------------------------

  TokenBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TokenBox& from);
  void MergeFrom(const TokenBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string passtoken = 1;
  inline bool has_passtoken() const;
  inline void clear_passtoken();
  static const int kPasstokenFieldNumber = 1;
  inline const ::std::string& passtoken() const;
  inline void set_passtoken(const ::std::string& value);
  inline void set_passtoken(const char* value);
  inline void set_passtoken(const char* value, size_t size);
  inline ::std::string* mutable_passtoken();
  inline ::std::string* release_passtoken();
  inline void set_allocated_passtoken(::std::string* passtoken);

  // required string servicetoken = 2;
  inline bool has_servicetoken() const;
  inline void clear_servicetoken();
  static const int kServicetokenFieldNumber = 2;
  inline const ::std::string& servicetoken() const;
  inline void set_servicetoken(const ::std::string& value);
  inline void set_servicetoken(const char* value);
  inline void set_servicetoken(const char* value, size_t size);
  inline ::std::string* mutable_servicetoken();
  inline ::std::string* release_servicetoken();
  inline void set_allocated_servicetoken(::std::string* servicetoken);

  // required string securitykey = 3;
  inline bool has_securitykey() const;
  inline void clear_securitykey();
  static const int kSecuritykeyFieldNumber = 3;
  inline const ::std::string& securitykey() const;
  inline void set_securitykey(const ::std::string& value);
  inline void set_securitykey(const char* value);
  inline void set_securitykey(const char* value, size_t size);
  inline ::std::string* mutable_securitykey();
  inline ::std::string* release_securitykey();
  inline void set_allocated_securitykey(::std::string* securitykey);

  // @@protoc_insertion_point(class_scope:zhibo_account.TokenBox)
 private:
  inline void set_has_passtoken();
  inline void clear_has_passtoken();
  inline void set_has_servicetoken();
  inline void clear_has_servicetoken();
  inline void set_has_securitykey();
  inline void clear_has_securitykey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* passtoken_;
  ::std::string* servicetoken_;
  ::std::string* securitykey_;
  friend void  protobuf_AddDesc_account_2eproto();
  friend void protobuf_AssignDesc_account_2eproto();
  friend void protobuf_ShutdownFile_account_2eproto();

  void InitAsDefaultInstance();
  static TokenBox* default_instance_;
};
// -------------------------------------------------------------------

class PassToken : public ::google::protobuf::Message {
 public:
  PassToken();
  virtual ~PassToken();

  PassToken(const PassToken& from);

  inline PassToken& operator=(const PassToken& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PassToken& default_instance();

  void Swap(PassToken* other);

  // implements Message ----------------------------------------------

  PassToken* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PassToken& from);
  void MergeFrom(const PassToken& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string keyword = 1;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 1;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // required uint64 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required uint32 account_type = 3;
  inline bool has_account_type() const;
  inline void clear_account_type();
  static const int kAccountTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 account_type() const;
  inline void set_account_type(::google::protobuf::uint32 value);

  // required uint32 create_ts = 4;
  inline bool has_create_ts() const;
  inline void clear_create_ts();
  static const int kCreateTsFieldNumber = 4;
  inline ::google::protobuf::uint32 create_ts() const;
  inline void set_create_ts(::google::protobuf::uint32 value);

  // required uint32 nonce = 5;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 5;
  inline ::google::protobuf::uint32 nonce() const;
  inline void set_nonce(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zhibo_account.PassToken)
 private:
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_account_type();
  inline void clear_has_account_type();
  inline void set_has_create_ts();
  inline void clear_has_create_ts();
  inline void set_has_nonce();
  inline void clear_has_nonce();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* keyword_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 account_type_;
  ::google::protobuf::uint32 create_ts_;
  ::google::protobuf::uint32 nonce_;
  friend void  protobuf_AddDesc_account_2eproto();
  friend void protobuf_AssignDesc_account_2eproto();
  friend void protobuf_ShutdownFile_account_2eproto();

  void InitAsDefaultInstance();
  static PassToken* default_instance_;
};
// -------------------------------------------------------------------

class ServiceToken : public ::google::protobuf::Message {
 public:
  ServiceToken();
  virtual ~ServiceToken();

  ServiceToken(const ServiceToken& from);

  inline ServiceToken& operator=(const ServiceToken& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceToken& default_instance();

  void Swap(ServiceToken* other);

  // implements Message ----------------------------------------------

  ServiceToken* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceToken& from);
  void MergeFrom(const ServiceToken& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string keyword = 1;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 1;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // required uint64 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required uint32 account_type = 3;
  inline bool has_account_type() const;
  inline void clear_account_type();
  static const int kAccountTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 account_type() const;
  inline void set_account_type(::google::protobuf::uint32 value);

  // required uint32 create_ts = 4;
  inline bool has_create_ts() const;
  inline void clear_create_ts();
  static const int kCreateTsFieldNumber = 4;
  inline ::google::protobuf::uint32 create_ts() const;
  inline void set_create_ts(::google::protobuf::uint32 value);

  // required uint32 nonce = 5;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 5;
  inline ::google::protobuf::uint32 nonce() const;
  inline void set_nonce(::google::protobuf::uint32 value);

  // required string securitykey = 6;
  inline bool has_securitykey() const;
  inline void clear_securitykey();
  static const int kSecuritykeyFieldNumber = 6;
  inline const ::std::string& securitykey() const;
  inline void set_securitykey(const ::std::string& value);
  inline void set_securitykey(const char* value);
  inline void set_securitykey(const char* value, size_t size);
  inline ::std::string* mutable_securitykey();
  inline ::std::string* release_securitykey();
  inline void set_allocated_securitykey(::std::string* securitykey);

  // optional uint32 appid = 7;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 7;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zhibo_account.ServiceToken)
 private:
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_account_type();
  inline void clear_has_account_type();
  inline void set_has_create_ts();
  inline void clear_has_create_ts();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_securitykey();
  inline void clear_has_securitykey();
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* keyword_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 account_type_;
  ::google::protobuf::uint32 create_ts_;
  ::std::string* securitykey_;
  ::google::protobuf::uint32 nonce_;
  ::google::protobuf::uint32 appid_;
  friend void  protobuf_AddDesc_account_2eproto();
  friend void protobuf_AssignDesc_account_2eproto();
  friend void protobuf_ShutdownFile_account_2eproto();

  void InitAsDefaultInstance();
  static ServiceToken* default_instance_;
};
// -------------------------------------------------------------------

class OpenAccountInfo : public ::google::protobuf::Message {
 public:
  OpenAccountInfo();
  virtual ~OpenAccountInfo();

  OpenAccountInfo(const OpenAccountInfo& from);

  inline OpenAccountInfo& operator=(const OpenAccountInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenAccountInfo& default_instance();

  void Swap(OpenAccountInfo* other);

  // implements Message ----------------------------------------------

  OpenAccountInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenAccountInfo& from);
  void MergeFrom(const OpenAccountInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string openid = 1 [default = ""];
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 1;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // required uint64 uid = 2 [default = 0];
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required string access_token = 3 [default = ""];
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 3;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // required uint32 expires_in = 4 [default = 0];
  inline bool has_expires_in() const;
  inline void clear_expires_in();
  static const int kExpiresInFieldNumber = 4;
  inline ::google::protobuf::uint32 expires_in() const;
  inline void set_expires_in(::google::protobuf::uint32 value);

  // required uint32 token_update_ts = 5 [default = 0];
  inline bool has_token_update_ts() const;
  inline void clear_token_update_ts();
  static const int kTokenUpdateTsFieldNumber = 5;
  inline ::google::protobuf::uint32 token_update_ts() const;
  inline void set_token_update_ts(::google::protobuf::uint32 value);

  // optional string refresh_token = 6;
  inline bool has_refresh_token() const;
  inline void clear_refresh_token();
  static const int kRefreshTokenFieldNumber = 6;
  inline const ::std::string& refresh_token() const;
  inline void set_refresh_token(const ::std::string& value);
  inline void set_refresh_token(const char* value);
  inline void set_refresh_token(const char* value, size_t size);
  inline ::std::string* mutable_refresh_token();
  inline ::std::string* release_refresh_token();
  inline void set_allocated_refresh_token(::std::string* refresh_token);

  // optional string unionid = 7;
  inline bool has_unionid() const;
  inline void clear_unionid();
  static const int kUnionidFieldNumber = 7;
  inline const ::std::string& unionid() const;
  inline void set_unionid(const ::std::string& value);
  inline void set_unionid(const char* value);
  inline void set_unionid(const char* value, size_t size);
  inline ::std::string* mutable_unionid();
  inline ::std::string* release_unionid();
  inline void set_allocated_unionid(::std::string* unionid);

  // @@protoc_insertion_point(class_scope:zhibo_account.OpenAccountInfo)
 private:
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_expires_in();
  inline void clear_has_expires_in();
  inline void set_has_token_update_ts();
  inline void clear_has_token_update_ts();
  inline void set_has_refresh_token();
  inline void clear_has_refresh_token();
  inline void set_has_unionid();
  inline void clear_has_unionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* openid_;
  ::google::protobuf::uint64 uid_;
  ::std::string* access_token_;
  ::google::protobuf::uint32 expires_in_;
  ::google::protobuf::uint32 token_update_ts_;
  ::std::string* refresh_token_;
  ::std::string* unionid_;
  friend void  protobuf_AddDesc_account_2eproto();
  friend void protobuf_AssignDesc_account_2eproto();
  friend void protobuf_ShutdownFile_account_2eproto();

  void InitAsDefaultInstance();
  static OpenAccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class AccountInfo : public ::google::protobuf::Message {
 public:
  AccountInfo();
  virtual ~AccountInfo();

  AccountInfo(const AccountInfo& from);

  inline AccountInfo& operator=(const AccountInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountInfo& default_instance();

  void Swap(AccountInfo* other);

  // implements Message ----------------------------------------------

  AccountInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountInfo& from);
  void MergeFrom(const AccountInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required string openid = 2;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 2;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // required uint32 account_type = 3;
  inline bool has_account_type() const;
  inline void clear_account_type();
  static const int kAccountTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 account_type() const;
  inline void set_account_type(::google::protobuf::uint32 value);

  // required uint64 create_ts = 4;
  inline bool has_create_ts() const;
  inline void clear_create_ts();
  static const int kCreateTsFieldNumber = 4;
  inline ::google::protobuf::uint64 create_ts() const;
  inline void set_create_ts(::google::protobuf::uint64 value);

  // optional string unionid = 5;
  inline bool has_unionid() const;
  inline void clear_unionid();
  static const int kUnionidFieldNumber = 5;
  inline const ::std::string& unionid() const;
  inline void set_unionid(const ::std::string& value);
  inline void set_unionid(const char* value);
  inline void set_unionid(const char* value, size_t size);
  inline ::std::string* mutable_unionid();
  inline ::std::string* release_unionid();
  inline void set_allocated_unionid(::std::string* unionid);

  // @@protoc_insertion_point(class_scope:zhibo_account.AccountInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_account_type();
  inline void clear_has_account_type();
  inline void set_has_create_ts();
  inline void clear_has_create_ts();
  inline void set_has_unionid();
  inline void clear_has_unionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uid_;
  ::std::string* openid_;
  ::google::protobuf::uint64 create_ts_;
  ::std::string* unionid_;
  ::google::protobuf::uint32 account_type_;
  friend void  protobuf_AddDesc_account_2eproto();
  friend void protobuf_AssignDesc_account_2eproto();
  friend void protobuf_ShutdownFile_account_2eproto();

  void InitAsDefaultInstance();
  static AccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class OpenAccountInfoStore : public ::google::protobuf::Message {
 public:
  OpenAccountInfoStore();
  virtual ~OpenAccountInfoStore();

  OpenAccountInfoStore(const OpenAccountInfoStore& from);

  inline OpenAccountInfoStore& operator=(const OpenAccountInfoStore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenAccountInfoStore& default_instance();

  void Swap(OpenAccountInfoStore* other);

  // implements Message ----------------------------------------------

  OpenAccountInfoStore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenAccountInfoStore& from);
  void MergeFrom(const OpenAccountInfoStore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool encrypted = 1;
  inline bool has_encrypted() const;
  inline void clear_encrypted();
  static const int kEncryptedFieldNumber = 1;
  inline bool encrypted() const;
  inline void set_encrypted(bool value);

  // required uint32 keyversion = 2;
  inline bool has_keyversion() const;
  inline void clear_keyversion();
  static const int kKeyversionFieldNumber = 2;
  inline ::google::protobuf::uint32 keyversion() const;
  inline void set_keyversion(::google::protobuf::uint32 value);

  // required string data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:zhibo_account.OpenAccountInfoStore)
 private:
  inline void set_has_encrypted();
  inline void clear_has_encrypted();
  inline void set_has_keyversion();
  inline void clear_has_keyversion();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool encrypted_;
  ::google::protobuf::uint32 keyversion_;
  ::std::string* data_;
  friend void  protobuf_AddDesc_account_2eproto();
  friend void protobuf_AssignDesc_account_2eproto();
  friend void protobuf_ShutdownFile_account_2eproto();

  void InitAsDefaultInstance();
  static OpenAccountInfoStore* default_instance_;
};
// -------------------------------------------------------------------

class PassTokenStore : public ::google::protobuf::Message {
 public:
  PassTokenStore();
  virtual ~PassTokenStore();

  PassTokenStore(const PassTokenStore& from);

  inline PassTokenStore& operator=(const PassTokenStore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PassTokenStore& default_instance();

  void Swap(PassTokenStore* other);

  // implements Message ----------------------------------------------

  PassTokenStore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PassTokenStore& from);
  void MergeFrom(const PassTokenStore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool encrypted = 1;
  inline bool has_encrypted() const;
  inline void clear_encrypted();
  static const int kEncryptedFieldNumber = 1;
  inline bool encrypted() const;
  inline void set_encrypted(bool value);

  // required uint32 keyversion = 2;
  inline bool has_keyversion() const;
  inline void clear_keyversion();
  static const int kKeyversionFieldNumber = 2;
  inline ::google::protobuf::uint32 keyversion() const;
  inline void set_keyversion(::google::protobuf::uint32 value);

  // required string data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:zhibo_account.PassTokenStore)
 private:
  inline void set_has_encrypted();
  inline void clear_has_encrypted();
  inline void set_has_keyversion();
  inline void clear_has_keyversion();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool encrypted_;
  ::google::protobuf::uint32 keyversion_;
  ::std::string* data_;
  friend void  protobuf_AddDesc_account_2eproto();
  friend void protobuf_AssignDesc_account_2eproto();
  friend void protobuf_ShutdownFile_account_2eproto();

  void InitAsDefaultInstance();
  static PassTokenStore* default_instance_;
};
// -------------------------------------------------------------------

class PwdInfo : public ::google::protobuf::Message {
 public:
  PwdInfo();
  virtual ~PwdInfo();

  PwdInfo(const PwdInfo& from);

  inline PwdInfo& operator=(const PwdInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PwdInfo& default_instance();

  void Swap(PwdInfo* other);

  // implements Message ----------------------------------------------

  PwdInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PwdInfo& from);
  void MergeFrom(const PwdInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool encrypted = 1;
  inline bool has_encrypted() const;
  inline void clear_encrypted();
  static const int kEncryptedFieldNumber = 1;
  inline bool encrypted() const;
  inline void set_encrypted(bool value);

  // required uint32 keyversion = 2;
  inline bool has_keyversion() const;
  inline void clear_keyversion();
  static const int kKeyversionFieldNumber = 2;
  inline ::google::protobuf::uint32 keyversion() const;
  inline void set_keyversion(::google::protobuf::uint32 value);

  // required uint64 uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required string pwd = 4;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 4;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  inline void set_allocated_pwd(::std::string* pwd);

  // required uint32 create_ts = 5;
  inline bool has_create_ts() const;
  inline void clear_create_ts();
  static const int kCreateTsFieldNumber = 5;
  inline ::google::protobuf::uint32 create_ts() const;
  inline void set_create_ts(::google::protobuf::uint32 value);

  // required uint32 update_ts = 6;
  inline bool has_update_ts() const;
  inline void clear_update_ts();
  static const int kUpdateTsFieldNumber = 6;
  inline ::google::protobuf::uint32 update_ts() const;
  inline void set_update_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zhibo_account.PwdInfo)
 private:
  inline void set_has_encrypted();
  inline void clear_has_encrypted();
  inline void set_has_keyversion();
  inline void clear_has_keyversion();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_pwd();
  inline void clear_has_pwd();
  inline void set_has_create_ts();
  inline void clear_has_create_ts();
  inline void set_has_update_ts();
  inline void clear_has_update_ts();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool encrypted_;
  ::google::protobuf::uint32 keyversion_;
  ::google::protobuf::uint64 uid_;
  ::std::string* pwd_;
  ::google::protobuf::uint32 create_ts_;
  ::google::protobuf::uint32 update_ts_;
  friend void  protobuf_AddDesc_account_2eproto();
  friend void protobuf_AssignDesc_account_2eproto();
  friend void protobuf_ShutdownFile_account_2eproto();

  void InitAsDefaultInstance();
  static PwdInfo* default_instance_;
};
// -------------------------------------------------------------------

class WxOldUserInfo : public ::google::protobuf::Message {
 public:
  WxOldUserInfo();
  virtual ~WxOldUserInfo();

  WxOldUserInfo(const WxOldUserInfo& from);

  inline WxOldUserInfo& operator=(const WxOldUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WxOldUserInfo& default_instance();

  void Swap(WxOldUserInfo* other);

  // implements Message ----------------------------------------------

  WxOldUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WxOldUserInfo& from);
  void MergeFrom(const WxOldUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::uint64 uuid() const;
  inline void set_uuid(::google::protobuf::uint64 value);

  // optional uint32 counter = 2;
  inline bool has_counter() const;
  inline void clear_counter();
  static const int kCounterFieldNumber = 2;
  inline ::google::protobuf::uint32 counter() const;
  inline void set_counter(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zhibo_account.WxOldUserInfo)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_counter();
  inline void clear_has_counter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uuid_;
  ::google::protobuf::uint32 counter_;
  friend void  protobuf_AddDesc_account_2eproto();
  friend void protobuf_AssignDesc_account_2eproto();
  friend void protobuf_ShutdownFile_account_2eproto();

  void InitAsDefaultInstance();
  static WxOldUserInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// OuterProfile

// optional string nickname = 1;
inline bool OuterProfile::has_nickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OuterProfile::set_has_nickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OuterProfile::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OuterProfile::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& OuterProfile::nickname() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OuterProfile.nickname)
  return *nickname_;
}
inline void OuterProfile::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.OuterProfile.nickname)
}
inline void OuterProfile::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.OuterProfile.nickname)
}
inline void OuterProfile::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.OuterProfile.nickname)
}
inline ::std::string* OuterProfile::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.OuterProfile.nickname)
  return nickname_;
}
inline ::std::string* OuterProfile::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OuterProfile::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.OuterProfile.nickname)
}

// optional string headimgurl = 2;
inline bool OuterProfile::has_headimgurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OuterProfile::set_has_headimgurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OuterProfile::clear_has_headimgurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OuterProfile::clear_headimgurl() {
  if (headimgurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_->clear();
  }
  clear_has_headimgurl();
}
inline const ::std::string& OuterProfile::headimgurl() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OuterProfile.headimgurl)
  return *headimgurl_;
}
inline void OuterProfile::set_headimgurl(const ::std::string& value) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.OuterProfile.headimgurl)
}
inline void OuterProfile::set_headimgurl(const char* value) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.OuterProfile.headimgurl)
}
inline void OuterProfile::set_headimgurl(const char* value, size_t size) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.OuterProfile.headimgurl)
}
inline ::std::string* OuterProfile::mutable_headimgurl() {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.OuterProfile.headimgurl)
  return headimgurl_;
}
inline ::std::string* OuterProfile::release_headimgurl() {
  clear_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = headimgurl_;
    headimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OuterProfile::set_allocated_headimgurl(::std::string* headimgurl) {
  if (headimgurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete headimgurl_;
  }
  if (headimgurl) {
    set_has_headimgurl();
    headimgurl_ = headimgurl;
  } else {
    clear_has_headimgurl();
    headimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.OuterProfile.headimgurl)
}

// optional uint32 sex = 3;
inline bool OuterProfile::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OuterProfile::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OuterProfile::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OuterProfile::clear_sex() {
  sex_ = 0u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 OuterProfile::sex() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OuterProfile.sex)
  return sex_;
}
inline void OuterProfile::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.OuterProfile.sex)
}

// optional uint32 certification_type = 4;
inline bool OuterProfile::has_certification_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OuterProfile::set_has_certification_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OuterProfile::clear_has_certification_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OuterProfile::clear_certification_type() {
  certification_type_ = 0u;
  clear_has_certification_type();
}
inline ::google::protobuf::uint32 OuterProfile::certification_type() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OuterProfile.certification_type)
  return certification_type_;
}
inline void OuterProfile::set_certification_type(::google::protobuf::uint32 value) {
  set_has_certification_type();
  certification_type_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.OuterProfile.certification_type)
}

// optional string certification = 5;
inline bool OuterProfile::has_certification() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OuterProfile::set_has_certification() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OuterProfile::clear_has_certification() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OuterProfile::clear_certification() {
  if (certification_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    certification_->clear();
  }
  clear_has_certification();
}
inline const ::std::string& OuterProfile::certification() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OuterProfile.certification)
  return *certification_;
}
inline void OuterProfile::set_certification(const ::std::string& value) {
  set_has_certification();
  if (certification_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    certification_ = new ::std::string;
  }
  certification_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.OuterProfile.certification)
}
inline void OuterProfile::set_certification(const char* value) {
  set_has_certification();
  if (certification_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    certification_ = new ::std::string;
  }
  certification_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.OuterProfile.certification)
}
inline void OuterProfile::set_certification(const char* value, size_t size) {
  set_has_certification();
  if (certification_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    certification_ = new ::std::string;
  }
  certification_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.OuterProfile.certification)
}
inline ::std::string* OuterProfile::mutable_certification() {
  set_has_certification();
  if (certification_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    certification_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.OuterProfile.certification)
  return certification_;
}
inline ::std::string* OuterProfile::release_certification() {
  clear_has_certification();
  if (certification_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = certification_;
    certification_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OuterProfile::set_allocated_certification(::std::string* certification) {
  if (certification_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete certification_;
  }
  if (certification) {
    set_has_certification();
    certification_ = certification;
  } else {
    clear_has_certification();
    certification_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.OuterProfile.certification)
}

// optional string uid = 6;
inline bool OuterProfile::has_uid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OuterProfile::set_has_uid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OuterProfile::clear_has_uid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OuterProfile::clear_uid() {
  if (uid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& OuterProfile::uid() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OuterProfile.uid)
  return *uid_;
}
inline void OuterProfile::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.OuterProfile.uid)
}
inline void OuterProfile::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.OuterProfile.uid)
}
inline void OuterProfile::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.OuterProfile.uid)
}
inline ::std::string* OuterProfile::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.OuterProfile.uid)
  return uid_;
}
inline ::std::string* OuterProfile::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OuterProfile::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.OuterProfile.uid)
}

// -------------------------------------------------------------------

// TokenBox

// required string passtoken = 1;
inline bool TokenBox::has_passtoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TokenBox::set_has_passtoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TokenBox::clear_has_passtoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TokenBox::clear_passtoken() {
  if (passtoken_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passtoken_->clear();
  }
  clear_has_passtoken();
}
inline const ::std::string& TokenBox::passtoken() const {
  // @@protoc_insertion_point(field_get:zhibo_account.TokenBox.passtoken)
  return *passtoken_;
}
inline void TokenBox::set_passtoken(const ::std::string& value) {
  set_has_passtoken();
  if (passtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passtoken_ = new ::std::string;
  }
  passtoken_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.TokenBox.passtoken)
}
inline void TokenBox::set_passtoken(const char* value) {
  set_has_passtoken();
  if (passtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passtoken_ = new ::std::string;
  }
  passtoken_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.TokenBox.passtoken)
}
inline void TokenBox::set_passtoken(const char* value, size_t size) {
  set_has_passtoken();
  if (passtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passtoken_ = new ::std::string;
  }
  passtoken_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.TokenBox.passtoken)
}
inline ::std::string* TokenBox::mutable_passtoken() {
  set_has_passtoken();
  if (passtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passtoken_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.TokenBox.passtoken)
  return passtoken_;
}
inline ::std::string* TokenBox::release_passtoken() {
  clear_has_passtoken();
  if (passtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = passtoken_;
    passtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TokenBox::set_allocated_passtoken(::std::string* passtoken) {
  if (passtoken_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete passtoken_;
  }
  if (passtoken) {
    set_has_passtoken();
    passtoken_ = passtoken;
  } else {
    clear_has_passtoken();
    passtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.TokenBox.passtoken)
}

// required string servicetoken = 2;
inline bool TokenBox::has_servicetoken() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TokenBox::set_has_servicetoken() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TokenBox::clear_has_servicetoken() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TokenBox::clear_servicetoken() {
  if (servicetoken_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servicetoken_->clear();
  }
  clear_has_servicetoken();
}
inline const ::std::string& TokenBox::servicetoken() const {
  // @@protoc_insertion_point(field_get:zhibo_account.TokenBox.servicetoken)
  return *servicetoken_;
}
inline void TokenBox::set_servicetoken(const ::std::string& value) {
  set_has_servicetoken();
  if (servicetoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servicetoken_ = new ::std::string;
  }
  servicetoken_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.TokenBox.servicetoken)
}
inline void TokenBox::set_servicetoken(const char* value) {
  set_has_servicetoken();
  if (servicetoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servicetoken_ = new ::std::string;
  }
  servicetoken_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.TokenBox.servicetoken)
}
inline void TokenBox::set_servicetoken(const char* value, size_t size) {
  set_has_servicetoken();
  if (servicetoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servicetoken_ = new ::std::string;
  }
  servicetoken_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.TokenBox.servicetoken)
}
inline ::std::string* TokenBox::mutable_servicetoken() {
  set_has_servicetoken();
  if (servicetoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servicetoken_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.TokenBox.servicetoken)
  return servicetoken_;
}
inline ::std::string* TokenBox::release_servicetoken() {
  clear_has_servicetoken();
  if (servicetoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = servicetoken_;
    servicetoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TokenBox::set_allocated_servicetoken(::std::string* servicetoken) {
  if (servicetoken_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete servicetoken_;
  }
  if (servicetoken) {
    set_has_servicetoken();
    servicetoken_ = servicetoken;
  } else {
    clear_has_servicetoken();
    servicetoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.TokenBox.servicetoken)
}

// required string securitykey = 3;
inline bool TokenBox::has_securitykey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TokenBox::set_has_securitykey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TokenBox::clear_has_securitykey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TokenBox::clear_securitykey() {
  if (securitykey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    securitykey_->clear();
  }
  clear_has_securitykey();
}
inline const ::std::string& TokenBox::securitykey() const {
  // @@protoc_insertion_point(field_get:zhibo_account.TokenBox.securitykey)
  return *securitykey_;
}
inline void TokenBox::set_securitykey(const ::std::string& value) {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    securitykey_ = new ::std::string;
  }
  securitykey_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.TokenBox.securitykey)
}
inline void TokenBox::set_securitykey(const char* value) {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    securitykey_ = new ::std::string;
  }
  securitykey_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.TokenBox.securitykey)
}
inline void TokenBox::set_securitykey(const char* value, size_t size) {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    securitykey_ = new ::std::string;
  }
  securitykey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.TokenBox.securitykey)
}
inline ::std::string* TokenBox::mutable_securitykey() {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    securitykey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.TokenBox.securitykey)
  return securitykey_;
}
inline ::std::string* TokenBox::release_securitykey() {
  clear_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = securitykey_;
    securitykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TokenBox::set_allocated_securitykey(::std::string* securitykey) {
  if (securitykey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete securitykey_;
  }
  if (securitykey) {
    set_has_securitykey();
    securitykey_ = securitykey;
  } else {
    clear_has_securitykey();
    securitykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.TokenBox.securitykey)
}

// -------------------------------------------------------------------

// PassToken

// required string keyword = 1;
inline bool PassToken::has_keyword() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PassToken::set_has_keyword() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PassToken::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PassToken::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& PassToken::keyword() const {
  // @@protoc_insertion_point(field_get:zhibo_account.PassToken.keyword)
  return *keyword_;
}
inline void PassToken::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.PassToken.keyword)
}
inline void PassToken::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.PassToken.keyword)
}
inline void PassToken::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.PassToken.keyword)
}
inline ::std::string* PassToken::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyword_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.PassToken.keyword)
  return keyword_;
}
inline ::std::string* PassToken::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PassToken::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.PassToken.keyword)
}

// required uint64 uid = 2;
inline bool PassToken::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PassToken::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PassToken::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PassToken::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 PassToken::uid() const {
  // @@protoc_insertion_point(field_get:zhibo_account.PassToken.uid)
  return uid_;
}
inline void PassToken::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.PassToken.uid)
}

// required uint32 account_type = 3;
inline bool PassToken::has_account_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PassToken::set_has_account_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PassToken::clear_has_account_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PassToken::clear_account_type() {
  account_type_ = 0u;
  clear_has_account_type();
}
inline ::google::protobuf::uint32 PassToken::account_type() const {
  // @@protoc_insertion_point(field_get:zhibo_account.PassToken.account_type)
  return account_type_;
}
inline void PassToken::set_account_type(::google::protobuf::uint32 value) {
  set_has_account_type();
  account_type_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.PassToken.account_type)
}

// required uint32 create_ts = 4;
inline bool PassToken::has_create_ts() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PassToken::set_has_create_ts() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PassToken::clear_has_create_ts() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PassToken::clear_create_ts() {
  create_ts_ = 0u;
  clear_has_create_ts();
}
inline ::google::protobuf::uint32 PassToken::create_ts() const {
  // @@protoc_insertion_point(field_get:zhibo_account.PassToken.create_ts)
  return create_ts_;
}
inline void PassToken::set_create_ts(::google::protobuf::uint32 value) {
  set_has_create_ts();
  create_ts_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.PassToken.create_ts)
}

// required uint32 nonce = 5;
inline bool PassToken::has_nonce() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PassToken::set_has_nonce() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PassToken::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PassToken::clear_nonce() {
  nonce_ = 0u;
  clear_has_nonce();
}
inline ::google::protobuf::uint32 PassToken::nonce() const {
  // @@protoc_insertion_point(field_get:zhibo_account.PassToken.nonce)
  return nonce_;
}
inline void PassToken::set_nonce(::google::protobuf::uint32 value) {
  set_has_nonce();
  nonce_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.PassToken.nonce)
}

// -------------------------------------------------------------------

// ServiceToken

// required string keyword = 1;
inline bool ServiceToken::has_keyword() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceToken::set_has_keyword() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceToken::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceToken::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& ServiceToken::keyword() const {
  // @@protoc_insertion_point(field_get:zhibo_account.ServiceToken.keyword)
  return *keyword_;
}
inline void ServiceToken::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.ServiceToken.keyword)
}
inline void ServiceToken::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.ServiceToken.keyword)
}
inline void ServiceToken::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.ServiceToken.keyword)
}
inline ::std::string* ServiceToken::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyword_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.ServiceToken.keyword)
  return keyword_;
}
inline ::std::string* ServiceToken::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServiceToken::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.ServiceToken.keyword)
}

// required uint64 uid = 2;
inline bool ServiceToken::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceToken::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceToken::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceToken::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 ServiceToken::uid() const {
  // @@protoc_insertion_point(field_get:zhibo_account.ServiceToken.uid)
  return uid_;
}
inline void ServiceToken::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.ServiceToken.uid)
}

// required uint32 account_type = 3;
inline bool ServiceToken::has_account_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceToken::set_has_account_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceToken::clear_has_account_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceToken::clear_account_type() {
  account_type_ = 0u;
  clear_has_account_type();
}
inline ::google::protobuf::uint32 ServiceToken::account_type() const {
  // @@protoc_insertion_point(field_get:zhibo_account.ServiceToken.account_type)
  return account_type_;
}
inline void ServiceToken::set_account_type(::google::protobuf::uint32 value) {
  set_has_account_type();
  account_type_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.ServiceToken.account_type)
}

// required uint32 create_ts = 4;
inline bool ServiceToken::has_create_ts() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceToken::set_has_create_ts() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceToken::clear_has_create_ts() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceToken::clear_create_ts() {
  create_ts_ = 0u;
  clear_has_create_ts();
}
inline ::google::protobuf::uint32 ServiceToken::create_ts() const {
  // @@protoc_insertion_point(field_get:zhibo_account.ServiceToken.create_ts)
  return create_ts_;
}
inline void ServiceToken::set_create_ts(::google::protobuf::uint32 value) {
  set_has_create_ts();
  create_ts_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.ServiceToken.create_ts)
}

// required uint32 nonce = 5;
inline bool ServiceToken::has_nonce() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServiceToken::set_has_nonce() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServiceToken::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServiceToken::clear_nonce() {
  nonce_ = 0u;
  clear_has_nonce();
}
inline ::google::protobuf::uint32 ServiceToken::nonce() const {
  // @@protoc_insertion_point(field_get:zhibo_account.ServiceToken.nonce)
  return nonce_;
}
inline void ServiceToken::set_nonce(::google::protobuf::uint32 value) {
  set_has_nonce();
  nonce_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.ServiceToken.nonce)
}

// required string securitykey = 6;
inline bool ServiceToken::has_securitykey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServiceToken::set_has_securitykey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServiceToken::clear_has_securitykey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServiceToken::clear_securitykey() {
  if (securitykey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    securitykey_->clear();
  }
  clear_has_securitykey();
}
inline const ::std::string& ServiceToken::securitykey() const {
  // @@protoc_insertion_point(field_get:zhibo_account.ServiceToken.securitykey)
  return *securitykey_;
}
inline void ServiceToken::set_securitykey(const ::std::string& value) {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    securitykey_ = new ::std::string;
  }
  securitykey_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.ServiceToken.securitykey)
}
inline void ServiceToken::set_securitykey(const char* value) {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    securitykey_ = new ::std::string;
  }
  securitykey_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.ServiceToken.securitykey)
}
inline void ServiceToken::set_securitykey(const char* value, size_t size) {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    securitykey_ = new ::std::string;
  }
  securitykey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.ServiceToken.securitykey)
}
inline ::std::string* ServiceToken::mutable_securitykey() {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    securitykey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.ServiceToken.securitykey)
  return securitykey_;
}
inline ::std::string* ServiceToken::release_securitykey() {
  clear_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = securitykey_;
    securitykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServiceToken::set_allocated_securitykey(::std::string* securitykey) {
  if (securitykey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete securitykey_;
  }
  if (securitykey) {
    set_has_securitykey();
    securitykey_ = securitykey;
  } else {
    clear_has_securitykey();
    securitykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.ServiceToken.securitykey)
}

// optional uint32 appid = 7;
inline bool ServiceToken::has_appid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServiceToken::set_has_appid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServiceToken::clear_has_appid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServiceToken::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 ServiceToken::appid() const {
  // @@protoc_insertion_point(field_get:zhibo_account.ServiceToken.appid)
  return appid_;
}
inline void ServiceToken::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.ServiceToken.appid)
}

// -------------------------------------------------------------------

// OpenAccountInfo

// required string openid = 1 [default = ""];
inline bool OpenAccountInfo::has_openid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenAccountInfo::set_has_openid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenAccountInfo::clear_has_openid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenAccountInfo::clear_openid() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& OpenAccountInfo::openid() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OpenAccountInfo.openid)
  return *openid_;
}
inline void OpenAccountInfo::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.OpenAccountInfo.openid)
}
inline void OpenAccountInfo::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.OpenAccountInfo.openid)
}
inline void OpenAccountInfo::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.OpenAccountInfo.openid)
}
inline ::std::string* OpenAccountInfo::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.OpenAccountInfo.openid)
  return openid_;
}
inline ::std::string* OpenAccountInfo::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OpenAccountInfo::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.OpenAccountInfo.openid)
}

// required uint64 uid = 2 [default = 0];
inline bool OpenAccountInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenAccountInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenAccountInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenAccountInfo::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 OpenAccountInfo::uid() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OpenAccountInfo.uid)
  return uid_;
}
inline void OpenAccountInfo::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.OpenAccountInfo.uid)
}

// required string access_token = 3 [default = ""];
inline bool OpenAccountInfo::has_access_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpenAccountInfo::set_has_access_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpenAccountInfo::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpenAccountInfo::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& OpenAccountInfo::access_token() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OpenAccountInfo.access_token)
  return *access_token_;
}
inline void OpenAccountInfo::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.OpenAccountInfo.access_token)
}
inline void OpenAccountInfo::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.OpenAccountInfo.access_token)
}
inline void OpenAccountInfo::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.OpenAccountInfo.access_token)
}
inline ::std::string* OpenAccountInfo::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.OpenAccountInfo.access_token)
  return access_token_;
}
inline ::std::string* OpenAccountInfo::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OpenAccountInfo::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.OpenAccountInfo.access_token)
}

// required uint32 expires_in = 4 [default = 0];
inline bool OpenAccountInfo::has_expires_in() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OpenAccountInfo::set_has_expires_in() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OpenAccountInfo::clear_has_expires_in() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OpenAccountInfo::clear_expires_in() {
  expires_in_ = 0u;
  clear_has_expires_in();
}
inline ::google::protobuf::uint32 OpenAccountInfo::expires_in() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OpenAccountInfo.expires_in)
  return expires_in_;
}
inline void OpenAccountInfo::set_expires_in(::google::protobuf::uint32 value) {
  set_has_expires_in();
  expires_in_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.OpenAccountInfo.expires_in)
}

// required uint32 token_update_ts = 5 [default = 0];
inline bool OpenAccountInfo::has_token_update_ts() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OpenAccountInfo::set_has_token_update_ts() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OpenAccountInfo::clear_has_token_update_ts() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OpenAccountInfo::clear_token_update_ts() {
  token_update_ts_ = 0u;
  clear_has_token_update_ts();
}
inline ::google::protobuf::uint32 OpenAccountInfo::token_update_ts() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OpenAccountInfo.token_update_ts)
  return token_update_ts_;
}
inline void OpenAccountInfo::set_token_update_ts(::google::protobuf::uint32 value) {
  set_has_token_update_ts();
  token_update_ts_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.OpenAccountInfo.token_update_ts)
}

// optional string refresh_token = 6;
inline bool OpenAccountInfo::has_refresh_token() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OpenAccountInfo::set_has_refresh_token() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OpenAccountInfo::clear_has_refresh_token() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OpenAccountInfo::clear_refresh_token() {
  if (refresh_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refresh_token_->clear();
  }
  clear_has_refresh_token();
}
inline const ::std::string& OpenAccountInfo::refresh_token() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OpenAccountInfo.refresh_token)
  return *refresh_token_;
}
inline void OpenAccountInfo::set_refresh_token(const ::std::string& value) {
  set_has_refresh_token();
  if (refresh_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refresh_token_ = new ::std::string;
  }
  refresh_token_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.OpenAccountInfo.refresh_token)
}
inline void OpenAccountInfo::set_refresh_token(const char* value) {
  set_has_refresh_token();
  if (refresh_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refresh_token_ = new ::std::string;
  }
  refresh_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.OpenAccountInfo.refresh_token)
}
inline void OpenAccountInfo::set_refresh_token(const char* value, size_t size) {
  set_has_refresh_token();
  if (refresh_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refresh_token_ = new ::std::string;
  }
  refresh_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.OpenAccountInfo.refresh_token)
}
inline ::std::string* OpenAccountInfo::mutable_refresh_token() {
  set_has_refresh_token();
  if (refresh_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refresh_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.OpenAccountInfo.refresh_token)
  return refresh_token_;
}
inline ::std::string* OpenAccountInfo::release_refresh_token() {
  clear_has_refresh_token();
  if (refresh_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = refresh_token_;
    refresh_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OpenAccountInfo::set_allocated_refresh_token(::std::string* refresh_token) {
  if (refresh_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete refresh_token_;
  }
  if (refresh_token) {
    set_has_refresh_token();
    refresh_token_ = refresh_token;
  } else {
    clear_has_refresh_token();
    refresh_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.OpenAccountInfo.refresh_token)
}

// optional string unionid = 7;
inline bool OpenAccountInfo::has_unionid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OpenAccountInfo::set_has_unionid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OpenAccountInfo::clear_has_unionid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OpenAccountInfo::clear_unionid() {
  if (unionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_->clear();
  }
  clear_has_unionid();
}
inline const ::std::string& OpenAccountInfo::unionid() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OpenAccountInfo.unionid)
  return *unionid_;
}
inline void OpenAccountInfo::set_unionid(const ::std::string& value) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.OpenAccountInfo.unionid)
}
inline void OpenAccountInfo::set_unionid(const char* value) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.OpenAccountInfo.unionid)
}
inline void OpenAccountInfo::set_unionid(const char* value, size_t size) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.OpenAccountInfo.unionid)
}
inline ::std::string* OpenAccountInfo::mutable_unionid() {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.OpenAccountInfo.unionid)
  return unionid_;
}
inline ::std::string* OpenAccountInfo::release_unionid() {
  clear_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unionid_;
    unionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OpenAccountInfo::set_allocated_unionid(::std::string* unionid) {
  if (unionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unionid_;
  }
  if (unionid) {
    set_has_unionid();
    unionid_ = unionid;
  } else {
    clear_has_unionid();
    unionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.OpenAccountInfo.unionid)
}

// -------------------------------------------------------------------

// AccountInfo

// required uint64 uid = 1;
inline bool AccountInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountInfo::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 AccountInfo::uid() const {
  // @@protoc_insertion_point(field_get:zhibo_account.AccountInfo.uid)
  return uid_;
}
inline void AccountInfo::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.AccountInfo.uid)
}

// required string openid = 2;
inline bool AccountInfo::has_openid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountInfo::set_has_openid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountInfo::clear_has_openid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountInfo::clear_openid() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& AccountInfo::openid() const {
  // @@protoc_insertion_point(field_get:zhibo_account.AccountInfo.openid)
  return *openid_;
}
inline void AccountInfo::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.AccountInfo.openid)
}
inline void AccountInfo::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.AccountInfo.openid)
}
inline void AccountInfo::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.AccountInfo.openid)
}
inline ::std::string* AccountInfo::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.AccountInfo.openid)
  return openid_;
}
inline ::std::string* AccountInfo::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AccountInfo::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.AccountInfo.openid)
}

// required uint32 account_type = 3;
inline bool AccountInfo::has_account_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountInfo::set_has_account_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountInfo::clear_has_account_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountInfo::clear_account_type() {
  account_type_ = 0u;
  clear_has_account_type();
}
inline ::google::protobuf::uint32 AccountInfo::account_type() const {
  // @@protoc_insertion_point(field_get:zhibo_account.AccountInfo.account_type)
  return account_type_;
}
inline void AccountInfo::set_account_type(::google::protobuf::uint32 value) {
  set_has_account_type();
  account_type_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.AccountInfo.account_type)
}

// required uint64 create_ts = 4;
inline bool AccountInfo::has_create_ts() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountInfo::set_has_create_ts() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountInfo::clear_has_create_ts() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountInfo::clear_create_ts() {
  create_ts_ = GOOGLE_ULONGLONG(0);
  clear_has_create_ts();
}
inline ::google::protobuf::uint64 AccountInfo::create_ts() const {
  // @@protoc_insertion_point(field_get:zhibo_account.AccountInfo.create_ts)
  return create_ts_;
}
inline void AccountInfo::set_create_ts(::google::protobuf::uint64 value) {
  set_has_create_ts();
  create_ts_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.AccountInfo.create_ts)
}

// optional string unionid = 5;
inline bool AccountInfo::has_unionid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountInfo::set_has_unionid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountInfo::clear_has_unionid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountInfo::clear_unionid() {
  if (unionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_->clear();
  }
  clear_has_unionid();
}
inline const ::std::string& AccountInfo::unionid() const {
  // @@protoc_insertion_point(field_get:zhibo_account.AccountInfo.unionid)
  return *unionid_;
}
inline void AccountInfo::set_unionid(const ::std::string& value) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.AccountInfo.unionid)
}
inline void AccountInfo::set_unionid(const char* value) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.AccountInfo.unionid)
}
inline void AccountInfo::set_unionid(const char* value, size_t size) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.AccountInfo.unionid)
}
inline ::std::string* AccountInfo::mutable_unionid() {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.AccountInfo.unionid)
  return unionid_;
}
inline ::std::string* AccountInfo::release_unionid() {
  clear_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unionid_;
    unionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AccountInfo::set_allocated_unionid(::std::string* unionid) {
  if (unionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unionid_;
  }
  if (unionid) {
    set_has_unionid();
    unionid_ = unionid;
  } else {
    clear_has_unionid();
    unionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.AccountInfo.unionid)
}

// -------------------------------------------------------------------

// OpenAccountInfoStore

// required bool encrypted = 1;
inline bool OpenAccountInfoStore::has_encrypted() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenAccountInfoStore::set_has_encrypted() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenAccountInfoStore::clear_has_encrypted() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenAccountInfoStore::clear_encrypted() {
  encrypted_ = false;
  clear_has_encrypted();
}
inline bool OpenAccountInfoStore::encrypted() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OpenAccountInfoStore.encrypted)
  return encrypted_;
}
inline void OpenAccountInfoStore::set_encrypted(bool value) {
  set_has_encrypted();
  encrypted_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.OpenAccountInfoStore.encrypted)
}

// required uint32 keyversion = 2;
inline bool OpenAccountInfoStore::has_keyversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenAccountInfoStore::set_has_keyversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenAccountInfoStore::clear_has_keyversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenAccountInfoStore::clear_keyversion() {
  keyversion_ = 0u;
  clear_has_keyversion();
}
inline ::google::protobuf::uint32 OpenAccountInfoStore::keyversion() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OpenAccountInfoStore.keyversion)
  return keyversion_;
}
inline void OpenAccountInfoStore::set_keyversion(::google::protobuf::uint32 value) {
  set_has_keyversion();
  keyversion_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.OpenAccountInfoStore.keyversion)
}

// required string data = 3;
inline bool OpenAccountInfoStore::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpenAccountInfoStore::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpenAccountInfoStore::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpenAccountInfoStore::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& OpenAccountInfoStore::data() const {
  // @@protoc_insertion_point(field_get:zhibo_account.OpenAccountInfoStore.data)
  return *data_;
}
inline void OpenAccountInfoStore::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.OpenAccountInfoStore.data)
}
inline void OpenAccountInfoStore::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.OpenAccountInfoStore.data)
}
inline void OpenAccountInfoStore::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.OpenAccountInfoStore.data)
}
inline ::std::string* OpenAccountInfoStore::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.OpenAccountInfoStore.data)
  return data_;
}
inline ::std::string* OpenAccountInfoStore::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OpenAccountInfoStore::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.OpenAccountInfoStore.data)
}

// -------------------------------------------------------------------

// PassTokenStore

// required bool encrypted = 1;
inline bool PassTokenStore::has_encrypted() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PassTokenStore::set_has_encrypted() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PassTokenStore::clear_has_encrypted() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PassTokenStore::clear_encrypted() {
  encrypted_ = false;
  clear_has_encrypted();
}
inline bool PassTokenStore::encrypted() const {
  // @@protoc_insertion_point(field_get:zhibo_account.PassTokenStore.encrypted)
  return encrypted_;
}
inline void PassTokenStore::set_encrypted(bool value) {
  set_has_encrypted();
  encrypted_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.PassTokenStore.encrypted)
}

// required uint32 keyversion = 2;
inline bool PassTokenStore::has_keyversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PassTokenStore::set_has_keyversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PassTokenStore::clear_has_keyversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PassTokenStore::clear_keyversion() {
  keyversion_ = 0u;
  clear_has_keyversion();
}
inline ::google::protobuf::uint32 PassTokenStore::keyversion() const {
  // @@protoc_insertion_point(field_get:zhibo_account.PassTokenStore.keyversion)
  return keyversion_;
}
inline void PassTokenStore::set_keyversion(::google::protobuf::uint32 value) {
  set_has_keyversion();
  keyversion_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.PassTokenStore.keyversion)
}

// required string data = 3;
inline bool PassTokenStore::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PassTokenStore::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PassTokenStore::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PassTokenStore::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& PassTokenStore::data() const {
  // @@protoc_insertion_point(field_get:zhibo_account.PassTokenStore.data)
  return *data_;
}
inline void PassTokenStore::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.PassTokenStore.data)
}
inline void PassTokenStore::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.PassTokenStore.data)
}
inline void PassTokenStore::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.PassTokenStore.data)
}
inline ::std::string* PassTokenStore::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.PassTokenStore.data)
  return data_;
}
inline ::std::string* PassTokenStore::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PassTokenStore::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.PassTokenStore.data)
}

// -------------------------------------------------------------------

// PwdInfo

// required bool encrypted = 1;
inline bool PwdInfo::has_encrypted() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PwdInfo::set_has_encrypted() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PwdInfo::clear_has_encrypted() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PwdInfo::clear_encrypted() {
  encrypted_ = false;
  clear_has_encrypted();
}
inline bool PwdInfo::encrypted() const {
  // @@protoc_insertion_point(field_get:zhibo_account.PwdInfo.encrypted)
  return encrypted_;
}
inline void PwdInfo::set_encrypted(bool value) {
  set_has_encrypted();
  encrypted_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.PwdInfo.encrypted)
}

// required uint32 keyversion = 2;
inline bool PwdInfo::has_keyversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PwdInfo::set_has_keyversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PwdInfo::clear_has_keyversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PwdInfo::clear_keyversion() {
  keyversion_ = 0u;
  clear_has_keyversion();
}
inline ::google::protobuf::uint32 PwdInfo::keyversion() const {
  // @@protoc_insertion_point(field_get:zhibo_account.PwdInfo.keyversion)
  return keyversion_;
}
inline void PwdInfo::set_keyversion(::google::protobuf::uint32 value) {
  set_has_keyversion();
  keyversion_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.PwdInfo.keyversion)
}

// required uint64 uid = 3;
inline bool PwdInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PwdInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PwdInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PwdInfo::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 PwdInfo::uid() const {
  // @@protoc_insertion_point(field_get:zhibo_account.PwdInfo.uid)
  return uid_;
}
inline void PwdInfo::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.PwdInfo.uid)
}

// required string pwd = 4;
inline bool PwdInfo::has_pwd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PwdInfo::set_has_pwd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PwdInfo::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PwdInfo::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& PwdInfo::pwd() const {
  // @@protoc_insertion_point(field_get:zhibo_account.PwdInfo.pwd)
  return *pwd_;
}
inline void PwdInfo::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
  // @@protoc_insertion_point(field_set:zhibo_account.PwdInfo.pwd)
}
inline void PwdInfo::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
  // @@protoc_insertion_point(field_set_char:zhibo_account.PwdInfo.pwd)
}
inline void PwdInfo::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zhibo_account.PwdInfo.pwd)
}
inline ::std::string* PwdInfo::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zhibo_account.PwdInfo.pwd)
  return pwd_;
}
inline ::std::string* PwdInfo::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PwdInfo::set_allocated_pwd(::std::string* pwd) {
  if (pwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pwd_;
  }
  if (pwd) {
    set_has_pwd();
    pwd_ = pwd;
  } else {
    clear_has_pwd();
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zhibo_account.PwdInfo.pwd)
}

// required uint32 create_ts = 5;
inline bool PwdInfo::has_create_ts() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PwdInfo::set_has_create_ts() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PwdInfo::clear_has_create_ts() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PwdInfo::clear_create_ts() {
  create_ts_ = 0u;
  clear_has_create_ts();
}
inline ::google::protobuf::uint32 PwdInfo::create_ts() const {
  // @@protoc_insertion_point(field_get:zhibo_account.PwdInfo.create_ts)
  return create_ts_;
}
inline void PwdInfo::set_create_ts(::google::protobuf::uint32 value) {
  set_has_create_ts();
  create_ts_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.PwdInfo.create_ts)
}

// required uint32 update_ts = 6;
inline bool PwdInfo::has_update_ts() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PwdInfo::set_has_update_ts() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PwdInfo::clear_has_update_ts() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PwdInfo::clear_update_ts() {
  update_ts_ = 0u;
  clear_has_update_ts();
}
inline ::google::protobuf::uint32 PwdInfo::update_ts() const {
  // @@protoc_insertion_point(field_get:zhibo_account.PwdInfo.update_ts)
  return update_ts_;
}
inline void PwdInfo::set_update_ts(::google::protobuf::uint32 value) {
  set_has_update_ts();
  update_ts_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.PwdInfo.update_ts)
}

// -------------------------------------------------------------------

// WxOldUserInfo

// required uint64 uuid = 1;
inline bool WxOldUserInfo::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WxOldUserInfo::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WxOldUserInfo::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WxOldUserInfo::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 WxOldUserInfo::uuid() const {
  // @@protoc_insertion_point(field_get:zhibo_account.WxOldUserInfo.uuid)
  return uuid_;
}
inline void WxOldUserInfo::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.WxOldUserInfo.uuid)
}

// optional uint32 counter = 2;
inline bool WxOldUserInfo::has_counter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WxOldUserInfo::set_has_counter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WxOldUserInfo::clear_has_counter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WxOldUserInfo::clear_counter() {
  counter_ = 0u;
  clear_has_counter();
}
inline ::google::protobuf::uint32 WxOldUserInfo::counter() const {
  // @@protoc_insertion_point(field_get:zhibo_account.WxOldUserInfo.counter)
  return counter_;
}
inline void WxOldUserInfo::set_counter(::google::protobuf::uint32 value) {
  set_has_counter();
  counter_ = value;
  // @@protoc_insertion_point(field_set:zhibo_account.WxOldUserInfo.counter)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace zhibo_account

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_account_2eproto__INCLUDED
